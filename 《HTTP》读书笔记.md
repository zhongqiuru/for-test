## HTTP及TCP/IP协议

通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。

#### TCP/IP 的分层管理
层次分为以下4层
- 应用层（应用层决定了向用户提供应用服务时通信的活动。）
- 传输层（传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。）
- 网络层（网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（*所谓的传输路线*）到达对方计算机，并把数据包传送给对方。）
- 数据链路层（用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（*Network Interface Card，网络适配器，即网卡*），及光纤等物理可见部分（*还包括连接器等一切传输媒介*）。硬件上的范畴均在链路层的作用范围之内。）

#### TCP/IP 通信传输流
![image](https://wx1.sinaimg.cn/mw690/b040101agy1fyw4eobal4j20jg0f5ace.jpg)
利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。

应用层（HTTP协议）发出一个想看某个 Web 页面的 HTTP 请求。

接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

在网络层（IP协议），增加作为通信目的地的 MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。

接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。


#### IP 协议
- IP（Internet Protocol）网际协议位于网络层。

- TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。

- **IP-是一种协议的名称。**

- **IP协议-是把各种数据包传送给对方。**

#### TCP协议
TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。

若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。

#### URL和URI

与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址

*URI格式：协议方案名：//登录信息（认证）@服务器地址：服务器口号 带层次的文件路径？查询字符串#片段标识符*

#### 请求报文
响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

***
HTTP 协议自身不具备保存之前发送过的请求或响应的功能。

- HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。

#### 告知服务器意图的 HTTP 方法
- GET ：获取资源
- POST：传输实体主体
- PUT：传输文件
- DELETE：删除文件
- OPTIONS：询问支持的方法
- TRACE：追踪路径
- CONNECT：要求用隧道协议连接代理


#### HTTP报文
用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。

*HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。*

#### 请求报文及响应报文的结构
- 请求行
[包含用于请求的方法，请求 URI 和 HTTP 版本。]
- 状态行
[包含表明响应结果的状态码，原因短语和 HTTP 版本。]
- 首部字段
[包含表示请求和响应的各种条件和属性的各类首部。
一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。]
- 其他
[可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。]

***

常用的内容编码有以下几种。
- gzip（GNU zip）
- compress（UNIX 系统的标准压缩）
- deflate（zlib）
- identity（不进行编码）


#### 多部分对象集合
- multipart/form-data
在 Web 表单文件上传时使用。
- multipart/byteranges
状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。
- multipart/form-data
复合文件
- multipart/byteranges

#### 内容协商技术
- 服务器驱动协商（Server-driven Negotiation）
- 客户端驱动协商（Agent-driven Negotiation）
- 透明协商（Transparent Negotiation）


#### 状态码

1XX | 信息性状态码
---|---
| 2XX | 成功状态码   |
|3XX  |  重定向状态码|
|4XX|客户端错误状态码|
|5XX |服务器错误状态码|

#### 通信数据转发程序 ：代理、网关、隧道
**代理**:
扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
- 缓存代理
- 透明代理

**网关**：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。

**隧道**：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

#### HTTP 响应报文
在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。

***
|首部字段名|说明|
---|---
|Accept|	用户代理可处理的媒体类型|
|Accept-Charset|优先的字符集|
|Accept-Encoding|优先的内容编码|
|Accept-Language|优先的语言（自然语言）|
|Authorization|Web认证信息|
|Expect|期待服务器的特定行为 |
|From 	| 用户的电子邮箱地址 |
|Host |	 请求资源所在服务器 
|If-Match |	 比较实体标记（ETag） 
|If-Modified-Since |比较资源的更新时间
|If-None-Match 	| 比较实体标记（与 If-Match 相反） 
|If-Range |	 资源未更新时发送实体 Byte 的范围请求 
 |If-Unmodified-Since |比较资源的更新时间（与If-Modified-Since相反）	 |比较资源的更新时间（与If-Modified-Since相反） 
 |Max-Forwards 	| 最大传输逐跳数 
 |Proxy-Authorization |	 代理服务器要求客户端的认证信息 
 |Range |	 实体的字节范围请求 
 |Referer |	 对请求中 URI 的原始获取方 
 |TE |	 传输编码的优先级 
|User-Agent |	 HTTP 客户端程序的信息

#### 请求首部字段
**Accept**:首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

**Accept-Charset**: 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。

**Accept-Encoding** 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。
- gzip
- compress
- deflate
- identity

**Accept-Language**:用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。
**Authorization**: 是用来告知服务器，用户代理的认证信息（证书值）。

**Expect**:告知服务器，期望出现的某种特定行为。

**From**:告知服务器使用用户代理的用户的电子邮件地址。

**Host**:告知服务器，请求的资源所处的互联网主机名和端口号。

**If-Match**:条件请求,服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

**If-Modified-Since**:告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。

#### HTTP+ 加密 + 认证 + 完整性保护 =HTTPS
- SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。

- 加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。

#### HTTPS 通信
**步骤 1**： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。

**步骤 2**： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。

**步骤 3**： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。

**步骤 4**： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。

**步骤 5**： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。

**步骤 6**： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。

**步骤 7**： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。

**步骤 8**： 服务器同样发送 Change Cipher Spec 报文。

**步骤 9**： 服务器同样发送 Finished 报文。

**步骤 10**： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。

**步骤 11**： 应用层协议通信，即发送 HTTP 响应。

**步骤 12**： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。

#### SSL 和 TLS

HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。
